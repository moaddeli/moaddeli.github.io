<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fa" xml:lang="fa" dir="rtl"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="HR Moaddeli">
<meta name="description" content="معرفی سیستم AMIE شرکت گوگل">

<title>AMIE – Hamidreza Moaddeli</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-71b63cd8563d634f2b55945d6dbaea61.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-WGM4V3CVY1"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WGM4V3CVY1', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Hamidreza Moaddeli</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../links.html"> 
<span class="menu-text">Links</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/moaddeli/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.github.com/moaddeli"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/hrmoaddeli"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AMIE</h1>
</div>

<div>
  <div class="description">
    معرفی سیستم AMIE شرکت گوگل
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>HR Moaddeli </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">۱ تیر ۱۴۰۴</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>در ژانویه ۲۰۲۴، شرکت گوگل از (AMIE (Articulate Medical Intelligence Explorer یک سیستم هوش مصنوعی تحقیقاتی مبتنی بر مدل‌های زبانی بزرگ (LLMs)، در وبلاگ خود رونمایی کرد. هم‌زمان، دو مقاله اولیه درباره این سیستم در arXiv منتشر شد که نسخه‌های نهایی آن‌ها در مارس ۲۰۲۵ در مجله Nature به چاپ رسید. AMIE حاصل همکاری دو بخش تحقیقاتی گوگل، یعنی Google Research و Google DeepMind است. از زمان معرفی اولیه، گوگل در سه پست وبلاگی، یافته‌های جدید و بهبودهای اعمال‌شده بر این سیستم را منتشر کرده است. این سیستم که بر پایه مدل زبانی چندمنظوره و عمومی PaLM-2 توسعه یافته، به‌طور ویژه برای مکالمات بالینی، دریافت شرح حال بیماران، و استدلال تشخیصی بهینه‌سازی شده است. هدف اصلی آن ارتقای دسترسی، کیفیت و ثبات در خدمات بهداشتی و سلامت است.</p>
<p><img src="amie1.gif" class="img-fluid"></p>
<p>مهم‌ترین دستاوردهای سیستم AMIE</p>
<ul>
<li><p>ایجاد یک محیط شبیه‌سازی شده برای مکالمات بالینی: این محیط مبتنی بر self-play طراحی شده و شامل مکانیزم‌های بازخورد خودکار است که به مقیاس‌پذیری و تسریع فرآیند یادگیری AMIE در طیف گسترده‌ای از تخصص‌های پزشکی و سناریوهای مختلف کمک می‌کند.</p></li>
<li><p>بهبود دقت تشخیصی و کیفیت مکالمه از طریق استراتژی زنجیره استدلال (chain-of-reasoning): این روش در مرحله استنتاج (inference) به کار گرفته می‌شود و شامل سه مرحله است: تحلیل اطلاعات بیمار، فرمول‌بندی پاسخ و اقدام، و پالایش پاسخ برای ارائه تشخیص دقیق‌تر.</p></li>
<li><p>توسعه چارچوب ارزیابی آزمایشی (pilot evaluation rubric): این چارچوب شامل معیارهای پزشک‌محور و بیمار‌محور است و بر اساس استانداردهای بالینی معتبر مانند شیوه‌های ارتباط بیمار‌محور (PCCBP)، معیارهای ارزیابی مهارت‌های معاینه بالینی (PACES) و پرسشنامه بیمار شورای پزشکی عمومی بریتانیا (GMCPQ) توسعه یافته است.</p></li>
<li><p>اجرای یک مطالعه بالینی کنترل‌شده به سبک OSCE (Objective Structured Clinical Examination): این مطالعه به‌صورت تصادفی، دوسوکور و متقاطع (crossover) طراحی شده است. در آن، ۱۵۹ سناریوی های موردی پزشکی از ارائه‌دهندگان خدمات درمانی در کانادا، بریتانیا و هند مورد بررسی قرار گرفت تا عملکرد AMIE در مقایسه با (PCPs (primary care physicians در مشاوره‌های متنی با بازیگران نقش بیمار Patient-actors ارزیابی شود. نهایتا عملکرد AMIE و پزشکان مراقبت‌های اولیه PCPs از دیدگاه پزشکان متخصص و بیماران شبیه‌سازی‌شده ارزیابی شده است. این سناریوهای موردی پزشکی طیف گسترده‌ای از تخصص‌های پزشکی و بیماری‌ها را پوشش می‌دادند.</p>
<ul>
<li>پزشکان مراقبت‌های اولیه: ۲۰ پزشک دارای گواهینامه بورد، با سابقه‌ای بین ۳ تا ۲۵ سال پس از دوره رزیدنتی، از هند و کانادا.<br>
</li>
<li>بازیگران نقش بیمار: ترکیبی از ۲۰ نفر شامل دانشجویان پزشکی، رزیدنت‌ها و پرستاران متخصص.<br>
</li>
<li>پزشکان متخصص ارزیاب: گروهی متشکل از ۳۳ پزشک متخصص، شامل ۱۸ نفر از هند، ۱۲ نفر از آمریکای شمالی و ۳ نفر از بریتانیا.</li>
</ul></li>
</ul>
<p><img src="amie2.png" class="img-fluid"></p>
<p>نتایج ارزیابی مطالعه بالینی کنترل‌شده نشان داد که سیستم AMIE در مقایسه با پزشکان مراقبت‌های اولیه PCPs، از دقت تشخیصی بالاتر و عملکرد بهتری در اغلب جنبه‌های ارزیابی برخوردار بوده است. علاوه بر این، در زمینه همدلی و مهارت‌های ارتباطی نیز عملکرد بهتری نشان داد. بر اساس ارزیابی پزشکان متخصص، AMIE در ۳۰ مورد از ۳۲ معیار برتری داشته و از دیدگاه بیماران شبیه‌سازی‌شده نیز در ۲۵ مورد از ۲۶ معیار، بهتر ارزیابی شده است. این یافته‌ها بیانگر آن است که AMIE در استخراج اطلاعات مرتبط در طول مشاوره‌های شبیه‌سازی‌شده به اندازه پزشکان مراقبت‌های اولیه ماهر بوده و در تفسیر این اطلاعات به منظور ارائه تشخیص‌های افتراقی دقیق‌تر و جامع‌تر، عملکرد بهتری داشته است.</p>
<p>این سیستم همچنین در تشخیص‌های افتراقی، با در نظر گرفتن k مقدار برتر از ۱ تا ۱۰، در مقایسه با پزشکان مراقبت‌های اولیه، هنگام تطبیق با تشخیص واقعی، دقت بالاتری نشان داده است.</p>
<p><img src="amie3.png" class="img-fluid"></p>
<p>در ارزیابی‌ها، دقت تشخیص افتراقی DDx به دست آمده توسط AMIE و پزشکان مراقبت‌های اولیه PCPs در شش تخصص پزشکی مورد بررسی قرار گرفت. نتایج نشان داد که عملکرد AMIE در تمامی تخصص‌ها با عملکرد PCP مطابقت داشته یا از آن بهتر بوده است، به جز در تخصص‌های زنان و زایمان/اورولوژی. بیشترین بهبود عملکرد در تخصص‌های داخلی و ریه مشاهده شده است.</p>
<p><img src="amie4.png" class="img-fluid"></p>
<p>همچنین در مطالعه ای تکمیلی قابلیت AMIE برای تولید تشخیص افتراقی DDx، چه به تنهایی و چه به عنوان ابزاری کمکی برای پزشکان بررسی شده است. این ارزیابی بر روی ۳۰۲ مورد چالش‌برانگیز پزشکی واقعی که از گزارش‌های کنفرانس‌های بالینی پاتولوژیک (CPCs) مجله پزشکی نیوانگلند (NEJM) جمع‌آوری شده بودند، انجام شد.</p>
<p>یافته‌های کلیدی این مطالعه عبارتند از:</p>
<ul>
<li><p>AMIE به تنهایی عملکردی برتر از پزشکان بدون کمک در تولید لیست‌های DDx نشان داد. برای مثال، دقت Top-10 برای AMIE به تنهایی ۵۹.۱٪ بود، در حالی که برای پزشکان بدون کمک ۳۳.۶٪ بود .</p></li>
<li><p>پزشکانی که توسط AMIE کمک شدند، کیفیت تشخیص افتراقی بالاتری داشتند (۵۱.۷٪ مقابل ۳۶.۱٪ برای پزشکان بدون کمک و ۴۴.۴٪ برای پزشکان با کمک جستجو).</p></li>
<li><p>پزشکانی که توسط AMIE کمک می‌شدند، لیست‌های تشخیصی افتراقی جامع‌تری ارائه کردند نسبت به کسانی که بدون کمک AMIE بودند. این مطالعه نشان می‌دهد که AMIE پتانسیل بهبود استدلال تشخیصی و دقت پزشکان در موارد چالش‌برانگیز را دارد. همچنین پیشنهاد می‌کند که AMIE می‌تواند به توانمندسازی پزشکان و گسترش دسترسی بیماران به تخصص در سطح متخصصان کمک کند.</p></li>
</ul>
<p><img src="amie5.png" class="img-fluid"></p>
<p>مطالعه انجام شده روی AMIE دارای محدودیت‌های مهمی شامل موارد زیر است:</p>
<ul>
<li><p>رابط کاربری ناآشنا برای پزشکان: پزشکان شرکت‌کننده از یک رابط متنی استفاده کردند که در عمل بالینی رایج نیست.</p></li>
<li><p>ماهیت تحقیقاتی AMIE: این سیستم هنوز یک نمونه اولیه تحقیقاتی است و برای استفاده عمومی نیازمند پژوهش‌های گسترده‌تر است.</p></li>
<li><p>چالش‌های کاربردی در دنیای واقعی: موضوعاتی مانند عدالت در سلامت، حفظ حریم خصوصی، عملکرد تحت محدودیت‌های عملی و ایمنی فناوری باید مورد بررسی دقیق قرار گیرند.</p></li>
<li><p>عدم شبیه‌سازی کامل محیط بالینی: ارزیابی‌های اولیه، تعاملات واقعی پزشک-بیمار را کاملاً شبیه‌سازی نمی‌کنند.</p></li>
<li><p>چالش‌های بازآفرینی ویژگی‌های یک پزشک ماهر در هوش مصنوعی: ارتباط، اعتماد، تصمیم‌گیری حرفه‌ای و ایمنی مواردی هستند که برای پیاده‌سازی در هوش مصنوعی نیازمند مطالعات گسترده‌تر هستند.</p></li>
</ul>
<p>نتیجه‌گیری: در حالی که نتایج اولیه AMIE امیدوارکننده هستند، استفاده عملی از این سیستم در محیط‌های درمانی واقعی نیازمند پژوهش‌های گسترده‌تر و ارزیابی‌های دقیق‌تر است.</p>
<p>لینک به منابع:</p>
<p><a href="https://research.google/blog/amie-a-research-ai-system-for-diagnostic-medical-reasoning-and-conversations/" class="uri">https://research.google/blog/amie-a-research-ai-system-for-diagnostic-medical-reasoning-and-conversations/</a></p>
<p><a href="https://www.nature.com/articles/s41586-025-08866-7" class="uri">https://www.nature.com/articles/s41586-025-08866-7</a></p>
<p><a href="https://www.nature.com/articles/s41586-025-08869-4" class="uri">https://www.nature.com/articles/s41586-025-08869-4</a></p>
<p>مطالعات جدید و بهبودهای اعمال‌شده:</p>
<p><a href="https://research.google/blog/advancing-amie-towards-specialist-care-and-real-world-validation/" class="uri">https://research.google/blog/advancing-amie-towards-specialist-care-and-real-world-validation/</a></p>
<p><a href="https://research.google/blog/from-diagnosis-to-treatment-advancing-amie-for-longitudinal-disease-management/" class="uri">https://research.google/blog/from-diagnosis-to-treatment-advancing-amie-for-longitudinal-disease-management/</a></p>
<p><a href="https://research.google/blog/amie-gains-vision-a-research-ai-agent-for-multi-modal-diagnostic-dialogue/" class="uri">https://research.google/blog/amie-gains-vision-a-research-ai-agent-for-multi-modal-diagnostic-dialogue/</a></p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>